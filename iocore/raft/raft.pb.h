// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: raft.proto

#ifndef PROTOBUF_raft_2eproto__INCLUDED
#define PROTOBUF_raft_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace raft {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_raft_2eproto();
void protobuf_AssignDesc_raft_2eproto();
void protobuf_ShutdownFile_raft_2eproto();

class RaftConfigPb;
class RaftLogEntryPb;
class RaftMessagePb;

// ===================================================================

class RaftConfigPb : public ::google::protobuf::Message {
 public:
  RaftConfigPb();
  virtual ~RaftConfigPb();

  RaftConfigPb(const RaftConfigPb& from);

  inline RaftConfigPb& operator=(const RaftConfigPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftConfigPb& default_instance();

  void Swap(RaftConfigPb* other);

  // implements Message ----------------------------------------------

  RaftConfigPb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftConfigPb& from);
  void MergeFrom(const RaftConfigPb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string node = 1;
  inline int node_size() const;
  inline void clear_node();
  static const int kNodeFieldNumber = 1;
  inline const ::std::string& node(int index) const;
  inline ::std::string* mutable_node(int index);
  inline void set_node(int index, const ::std::string& value);
  inline void set_node(int index, const char* value);
  inline void set_node(int index, const char* value, size_t size);
  inline ::std::string* add_node();
  inline void add_node(const ::std::string& value);
  inline void add_node(const char* value);
  inline void add_node(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& node() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_node();

  // repeated string replica = 2;
  inline int replica_size() const;
  inline void clear_replica();
  static const int kReplicaFieldNumber = 2;
  inline const ::std::string& replica(int index) const;
  inline ::std::string* mutable_replica(int index);
  inline void set_replica(int index, const ::std::string& value);
  inline void set_replica(int index, const char* value);
  inline void set_replica(int index, const char* value, size_t size);
  inline ::std::string* add_replica();
  inline void add_replica(const ::std::string& value);
  inline void add_replica(const char* value);
  inline void add_replica(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& replica() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_replica();

  // optional int64 term = 3;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 3;
  inline ::google::protobuf::int64 term() const;
  inline void set_term(::google::protobuf::int64 value);

  // optional int64 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::int64 index() const;
  inline void set_index(::google::protobuf::int64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(RaftConfigPb)
  // @@protoc_insertion_point(class_scope:raft.RaftConfigPb)
 private:
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> node_;
  ::google::protobuf::RepeatedPtrField< ::std::string> replica_;
  ::google::protobuf::int64 term_;
  ::google::protobuf::int64 index_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2eproto();
  friend void protobuf_AssignDesc_raft_2eproto();
  friend void protobuf_ShutdownFile_raft_2eproto();

  void InitAsDefaultInstance();
  static RaftConfigPb* default_instance_;
};
// -------------------------------------------------------------------

class RaftLogEntryPb : public ::google::protobuf::Message {
 public:
  RaftLogEntryPb();
  virtual ~RaftLogEntryPb();

  RaftLogEntryPb(const RaftLogEntryPb& from);

  inline RaftLogEntryPb& operator=(const RaftLogEntryPb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftLogEntryPb& default_instance();

  void Swap(RaftLogEntryPb* other);

  // implements Message ----------------------------------------------

  RaftLogEntryPb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftLogEntryPb& from);
  void MergeFrom(const RaftLogEntryPb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // optional .raft.RaftConfigPb config = 2;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 2;
  inline const ::raft::RaftConfigPb& config() const;
  inline ::raft::RaftConfigPb* mutable_config();
  inline ::raft::RaftConfigPb* release_config();
  inline void set_allocated_config(::raft::RaftConfigPb* config);

  // optional int64 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::int64 index() const;
  inline void set_index(::google::protobuf::int64 value);

  // optional int64 extent = 4;
  inline bool has_extent() const;
  inline void clear_extent();
  static const int kExtentFieldNumber = 4;
  inline ::google::protobuf::int64 extent() const;
  inline void set_extent(::google::protobuf::int64 value);

  // optional int64 term = 5;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 5;
  inline ::google::protobuf::int64 term() const;
  inline void set_term(::google::protobuf::int64 value);

  // optional int64 previous_log_term = 6;
  inline bool has_previous_log_term() const;
  inline void clear_previous_log_term();
  static const int kPreviousLogTermFieldNumber = 6;
  inline ::google::protobuf::int64 previous_log_term() const;
  inline void set_previous_log_term(::google::protobuf::int64 value);

  // optional int64 previous_log_index = 7;
  inline bool has_previous_log_index() const;
  inline void clear_previous_log_index();
  static const int kPreviousLogIndexFieldNumber = 7;
  inline ::google::protobuf::int64 previous_log_index() const;
  inline void set_previous_log_index(::google::protobuf::int64 value);

  // optional string leader = 8;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 8;
  inline const ::std::string& leader() const;
  inline void set_leader(const ::std::string& value);
  inline void set_leader(const char* value);
  inline void set_leader(const char* value, size_t size);
  inline ::std::string* mutable_leader();
  inline ::std::string* release_leader();
  inline void set_allocated_leader(::std::string* leader);

  // optional int64 data_committed = 9;
  inline bool has_data_committed() const;
  inline void clear_data_committed();
  static const int kDataCommittedFieldNumber = 9;
  inline ::google::protobuf::int64 data_committed() const;
  inline void set_data_committed(::google::protobuf::int64 value);

  // optional int64 config_committed = 10;
  inline bool has_config_committed() const;
  inline void clear_config_committed();
  static const int kConfigCommittedFieldNumber = 10;
  inline ::google::protobuf::int64 config_committed() const;
  inline void set_config_committed(::google::protobuf::int64 value);

  // optional string vote = 11;
  inline bool has_vote() const;
  inline void clear_vote();
  static const int kVoteFieldNumber = 11;
  inline const ::std::string& vote() const;
  inline void set_vote(const ::std::string& value);
  inline void set_vote(const char* value);
  inline void set_vote(const char* value, size_t size);
  inline ::std::string* mutable_vote();
  inline ::std::string* release_vote();
  inline void set_allocated_vote(::std::string* vote);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(RaftLogEntryPb)
  // @@protoc_insertion_point(class_scope:raft.RaftLogEntryPb)
 private:
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_extent();
  inline void clear_has_extent();
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_previous_log_term();
  inline void clear_has_previous_log_term();
  inline void set_has_previous_log_index();
  inline void clear_has_previous_log_index();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_data_committed();
  inline void clear_has_data_committed();
  inline void set_has_config_committed();
  inline void clear_has_config_committed();
  inline void set_has_vote();
  inline void clear_has_vote();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* data_;
  ::raft::RaftConfigPb* config_;
  ::google::protobuf::int64 index_;
  ::google::protobuf::int64 extent_;
  ::google::protobuf::int64 term_;
  ::google::protobuf::int64 previous_log_term_;
  ::google::protobuf::int64 previous_log_index_;
  ::std::string* leader_;
  ::google::protobuf::int64 data_committed_;
  ::google::protobuf::int64 config_committed_;
  ::std::string* vote_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2eproto();
  friend void protobuf_AssignDesc_raft_2eproto();
  friend void protobuf_ShutdownFile_raft_2eproto();

  void InitAsDefaultInstance();
  static RaftLogEntryPb* default_instance_;
};
// -------------------------------------------------------------------

class RaftMessagePb : public ::google::protobuf::Message {
 public:
  RaftMessagePb();
  virtual ~RaftMessagePb();

  RaftMessagePb(const RaftMessagePb& from);

  inline RaftMessagePb& operator=(const RaftMessagePb& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RaftMessagePb& default_instance();

  void Swap(RaftMessagePb* other);

  // implements Message ----------------------------------------------

  RaftMessagePb* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RaftMessagePb& from);
  void MergeFrom(const RaftMessagePb& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 term = 1;
  inline bool has_term() const;
  inline void clear_term();
  static const int kTermFieldNumber = 1;
  inline ::google::protobuf::int64 term() const;
  inline void set_term(::google::protobuf::int64 value);

  // optional string from = 2;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 2;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string leader = 3;
  inline bool has_leader() const;
  inline void clear_leader();
  static const int kLeaderFieldNumber = 3;
  inline const ::std::string& leader() const;
  inline void set_leader(const ::std::string& value);
  inline void set_leader(const char* value);
  inline void set_leader(const char* value, size_t size);
  inline ::std::string* mutable_leader();
  inline ::std::string* release_leader();
  inline void set_allocated_leader(::std::string* leader);

  // optional int64 data_committed = 4;
  inline bool has_data_committed() const;
  inline void clear_data_committed();
  static const int kDataCommittedFieldNumber = 4;
  inline ::google::protobuf::int64 data_committed() const;
  inline void set_data_committed(::google::protobuf::int64 value);

  // optional int64 config_committed = 5;
  inline bool has_config_committed() const;
  inline void clear_config_committed();
  static const int kConfigCommittedFieldNumber = 5;
  inline ::google::protobuf::int64 config_committed() const;
  inline void set_config_committed(::google::protobuf::int64 value);

  // optional .raft.RaftLogEntryPb entry = 8;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 8;
  inline const ::raft::RaftLogEntryPb& entry() const;
  inline ::raft::RaftLogEntryPb* mutable_entry();
  inline ::raft::RaftLogEntryPb* release_entry();
  inline void set_allocated_entry(::raft::RaftLogEntryPb* entry);

  // optional bool nack = 9;
  inline bool has_nack() const;
  inline void clear_nack();
  static const int kNackFieldNumber = 9;
  inline bool nack() const;
  inline void set_nack(bool value);

  // optional int64 last_log_term = 10;
  inline bool has_last_log_term() const;
  inline void clear_last_log_term();
  static const int kLastLogTermFieldNumber = 10;
  inline ::google::protobuf::int64 last_log_term() const;
  inline void set_last_log_term(::google::protobuf::int64 value);

  // optional int64 last_log_index = 11;
  inline bool has_last_log_index() const;
  inline void clear_last_log_index();
  static const int kLastLogIndexFieldNumber = 11;
  inline ::google::protobuf::int64 last_log_index() const;
  inline void set_last_log_index(::google::protobuf::int64 value);

  // optional string vote = 12;
  inline bool has_vote() const;
  inline void clear_vote();
  static const int kVoteFieldNumber = 12;
  inline const ::std::string& vote() const;
  inline void set_vote(const ::std::string& value);
  inline void set_vote(const char* value);
  inline void set_vote(const char* value, size_t size);
  inline ::std::string* mutable_vote();
  inline ::std::string* release_vote();
  inline void set_allocated_vote(::std::string* vote);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(RaftMessagePb)
  // @@protoc_insertion_point(class_scope:raft.RaftMessagePb)
 private:
  inline void set_has_term();
  inline void clear_has_term();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_leader();
  inline void clear_has_leader();
  inline void set_has_data_committed();
  inline void clear_has_data_committed();
  inline void set_has_config_committed();
  inline void clear_has_config_committed();
  inline void set_has_entry();
  inline void clear_has_entry();
  inline void set_has_nack();
  inline void clear_has_nack();
  inline void set_has_last_log_term();
  inline void clear_has_last_log_term();
  inline void set_has_last_log_index();
  inline void clear_has_last_log_index();
  inline void set_has_vote();
  inline void clear_has_vote();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 term_;
  ::std::string* from_;
  ::std::string* leader_;
  ::google::protobuf::int64 data_committed_;
  ::google::protobuf::int64 config_committed_;
  ::raft::RaftLogEntryPb* entry_;
  ::google::protobuf::int64 last_log_term_;
  ::google::protobuf::int64 last_log_index_;
  ::std::string* vote_;
  bool nack_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_raft_2eproto();
  friend void protobuf_AssignDesc_raft_2eproto();
  friend void protobuf_ShutdownFile_raft_2eproto();

  void InitAsDefaultInstance();
  static RaftMessagePb* default_instance_;
};
// ===================================================================


// ===================================================================

// RaftConfigPb

// repeated string node = 1;
inline int RaftConfigPb::node_size() const {
  return node_.size();
}
inline void RaftConfigPb::clear_node() {
  node_.Clear();
}
inline const ::std::string& RaftConfigPb::node(int index) const {
  return node_.Get(index);
}
inline ::std::string* RaftConfigPb::mutable_node(int index) {
  return node_.Mutable(index);
}
inline void RaftConfigPb::set_node(int index, const ::std::string& value) {
  node_.Mutable(index)->assign(value);
}
inline void RaftConfigPb::set_node(int index, const char* value) {
  node_.Mutable(index)->assign(value);
}
inline void RaftConfigPb::set_node(int index, const char* value, size_t size) {
  node_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftConfigPb::add_node() {
  return node_.Add();
}
inline void RaftConfigPb::add_node(const ::std::string& value) {
  node_.Add()->assign(value);
}
inline void RaftConfigPb::add_node(const char* value) {
  node_.Add()->assign(value);
}
inline void RaftConfigPb::add_node(const char* value, size_t size) {
  node_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RaftConfigPb::node() const {
  return node_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RaftConfigPb::mutable_node() {
  return &node_;
}

// repeated string replica = 2;
inline int RaftConfigPb::replica_size() const {
  return replica_.size();
}
inline void RaftConfigPb::clear_replica() {
  replica_.Clear();
}
inline const ::std::string& RaftConfigPb::replica(int index) const {
  return replica_.Get(index);
}
inline ::std::string* RaftConfigPb::mutable_replica(int index) {
  return replica_.Mutable(index);
}
inline void RaftConfigPb::set_replica(int index, const ::std::string& value) {
  replica_.Mutable(index)->assign(value);
}
inline void RaftConfigPb::set_replica(int index, const char* value) {
  replica_.Mutable(index)->assign(value);
}
inline void RaftConfigPb::set_replica(int index, const char* value, size_t size) {
  replica_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftConfigPb::add_replica() {
  return replica_.Add();
}
inline void RaftConfigPb::add_replica(const ::std::string& value) {
  replica_.Add()->assign(value);
}
inline void RaftConfigPb::add_replica(const char* value) {
  replica_.Add()->assign(value);
}
inline void RaftConfigPb::add_replica(const char* value, size_t size) {
  replica_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RaftConfigPb::replica() const {
  return replica_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RaftConfigPb::mutable_replica() {
  return &replica_;
}

// optional int64 term = 3;
inline bool RaftConfigPb::has_term() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaftConfigPb::set_has_term() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaftConfigPb::clear_has_term() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaftConfigPb::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 RaftConfigPb::term() const {
  return term_;
}
inline void RaftConfigPb::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
}

// optional int64 index = 4;
inline bool RaftConfigPb::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RaftConfigPb::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RaftConfigPb::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RaftConfigPb::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::int64 RaftConfigPb::index() const {
  return index_;
}
inline void RaftConfigPb::set_index(::google::protobuf::int64 value) {
  set_has_index();
  index_ = value;
}

// -------------------------------------------------------------------

// RaftLogEntryPb

// optional bytes data = 1;
inline bool RaftLogEntryPb::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftLogEntryPb::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftLogEntryPb::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftLogEntryPb::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& RaftLogEntryPb::data() const {
  return *data_;
}
inline void RaftLogEntryPb::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RaftLogEntryPb::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void RaftLogEntryPb::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftLogEntryPb::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* RaftLogEntryPb::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftLogEntryPb::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .raft.RaftConfigPb config = 2;
inline bool RaftLogEntryPb::has_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftLogEntryPb::set_has_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftLogEntryPb::clear_has_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftLogEntryPb::clear_config() {
  if (config_ != NULL) config_->::raft::RaftConfigPb::Clear();
  clear_has_config();
}
inline const ::raft::RaftConfigPb& RaftLogEntryPb::config() const {
  return config_ != NULL ? *config_ : *default_instance_->config_;
}
inline ::raft::RaftConfigPb* RaftLogEntryPb::mutable_config() {
  set_has_config();
  if (config_ == NULL) config_ = new ::raft::RaftConfigPb;
  return config_;
}
inline ::raft::RaftConfigPb* RaftLogEntryPb::release_config() {
  clear_has_config();
  ::raft::RaftConfigPb* temp = config_;
  config_ = NULL;
  return temp;
}
inline void RaftLogEntryPb::set_allocated_config(::raft::RaftConfigPb* config) {
  delete config_;
  config_ = config;
  if (config) {
    set_has_config();
  } else {
    clear_has_config();
  }
}

// optional int64 index = 3;
inline bool RaftLogEntryPb::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaftLogEntryPb::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaftLogEntryPb::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaftLogEntryPb::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::int64 RaftLogEntryPb::index() const {
  return index_;
}
inline void RaftLogEntryPb::set_index(::google::protobuf::int64 value) {
  set_has_index();
  index_ = value;
}

// optional int64 extent = 4;
inline bool RaftLogEntryPb::has_extent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RaftLogEntryPb::set_has_extent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RaftLogEntryPb::clear_has_extent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RaftLogEntryPb::clear_extent() {
  extent_ = GOOGLE_LONGLONG(0);
  clear_has_extent();
}
inline ::google::protobuf::int64 RaftLogEntryPb::extent() const {
  return extent_;
}
inline void RaftLogEntryPb::set_extent(::google::protobuf::int64 value) {
  set_has_extent();
  extent_ = value;
}

// optional int64 term = 5;
inline bool RaftLogEntryPb::has_term() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RaftLogEntryPb::set_has_term() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RaftLogEntryPb::clear_has_term() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RaftLogEntryPb::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 RaftLogEntryPb::term() const {
  return term_;
}
inline void RaftLogEntryPb::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
}

// optional int64 previous_log_term = 6;
inline bool RaftLogEntryPb::has_previous_log_term() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RaftLogEntryPb::set_has_previous_log_term() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RaftLogEntryPb::clear_has_previous_log_term() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RaftLogEntryPb::clear_previous_log_term() {
  previous_log_term_ = GOOGLE_LONGLONG(0);
  clear_has_previous_log_term();
}
inline ::google::protobuf::int64 RaftLogEntryPb::previous_log_term() const {
  return previous_log_term_;
}
inline void RaftLogEntryPb::set_previous_log_term(::google::protobuf::int64 value) {
  set_has_previous_log_term();
  previous_log_term_ = value;
}

// optional int64 previous_log_index = 7;
inline bool RaftLogEntryPb::has_previous_log_index() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RaftLogEntryPb::set_has_previous_log_index() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RaftLogEntryPb::clear_has_previous_log_index() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RaftLogEntryPb::clear_previous_log_index() {
  previous_log_index_ = GOOGLE_LONGLONG(0);
  clear_has_previous_log_index();
}
inline ::google::protobuf::int64 RaftLogEntryPb::previous_log_index() const {
  return previous_log_index_;
}
inline void RaftLogEntryPb::set_previous_log_index(::google::protobuf::int64 value) {
  set_has_previous_log_index();
  previous_log_index_ = value;
}

// optional string leader = 8;
inline bool RaftLogEntryPb::has_leader() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RaftLogEntryPb::set_has_leader() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RaftLogEntryPb::clear_has_leader() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RaftLogEntryPb::clear_leader() {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    leader_->clear();
  }
  clear_has_leader();
}
inline const ::std::string& RaftLogEntryPb::leader() const {
  return *leader_;
}
inline void RaftLogEntryPb::set_leader(const ::std::string& value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void RaftLogEntryPb::set_leader(const char* value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void RaftLogEntryPb::set_leader(const char* value, size_t size) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftLogEntryPb::mutable_leader() {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  return leader_;
}
inline ::std::string* RaftLogEntryPb::release_leader() {
  clear_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leader_;
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftLogEntryPb::set_allocated_leader(::std::string* leader) {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    delete leader_;
  }
  if (leader) {
    set_has_leader();
    leader_ = leader;
  } else {
    clear_has_leader();
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 data_committed = 9;
inline bool RaftLogEntryPb::has_data_committed() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RaftLogEntryPb::set_has_data_committed() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RaftLogEntryPb::clear_has_data_committed() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RaftLogEntryPb::clear_data_committed() {
  data_committed_ = GOOGLE_LONGLONG(0);
  clear_has_data_committed();
}
inline ::google::protobuf::int64 RaftLogEntryPb::data_committed() const {
  return data_committed_;
}
inline void RaftLogEntryPb::set_data_committed(::google::protobuf::int64 value) {
  set_has_data_committed();
  data_committed_ = value;
}

// optional int64 config_committed = 10;
inline bool RaftLogEntryPb::has_config_committed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RaftLogEntryPb::set_has_config_committed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RaftLogEntryPb::clear_has_config_committed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RaftLogEntryPb::clear_config_committed() {
  config_committed_ = GOOGLE_LONGLONG(0);
  clear_has_config_committed();
}
inline ::google::protobuf::int64 RaftLogEntryPb::config_committed() const {
  return config_committed_;
}
inline void RaftLogEntryPb::set_config_committed(::google::protobuf::int64 value) {
  set_has_config_committed();
  config_committed_ = value;
}

// optional string vote = 11;
inline bool RaftLogEntryPb::has_vote() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RaftLogEntryPb::set_has_vote() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RaftLogEntryPb::clear_has_vote() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RaftLogEntryPb::clear_vote() {
  if (vote_ != &::google::protobuf::internal::kEmptyString) {
    vote_->clear();
  }
  clear_has_vote();
}
inline const ::std::string& RaftLogEntryPb::vote() const {
  return *vote_;
}
inline void RaftLogEntryPb::set_vote(const ::std::string& value) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(value);
}
inline void RaftLogEntryPb::set_vote(const char* value) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(value);
}
inline void RaftLogEntryPb::set_vote(const char* value, size_t size) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftLogEntryPb::mutable_vote() {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  return vote_;
}
inline ::std::string* RaftLogEntryPb::release_vote() {
  clear_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vote_;
    vote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftLogEntryPb::set_allocated_vote(::std::string* vote) {
  if (vote_ != &::google::protobuf::internal::kEmptyString) {
    delete vote_;
  }
  if (vote) {
    set_has_vote();
    vote_ = vote;
  } else {
    clear_has_vote();
    vote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RaftMessagePb

// optional int64 term = 1;
inline bool RaftMessagePb::has_term() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RaftMessagePb::set_has_term() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RaftMessagePb::clear_has_term() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RaftMessagePb::clear_term() {
  term_ = GOOGLE_LONGLONG(0);
  clear_has_term();
}
inline ::google::protobuf::int64 RaftMessagePb::term() const {
  return term_;
}
inline void RaftMessagePb::set_term(::google::protobuf::int64 value) {
  set_has_term();
  term_ = value;
}

// optional string from = 2;
inline bool RaftMessagePb::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RaftMessagePb::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RaftMessagePb::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RaftMessagePb::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& RaftMessagePb::from() const {
  return *from_;
}
inline void RaftMessagePb::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void RaftMessagePb::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void RaftMessagePb::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftMessagePb::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* RaftMessagePb::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftMessagePb::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leader = 3;
inline bool RaftMessagePb::has_leader() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RaftMessagePb::set_has_leader() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RaftMessagePb::clear_has_leader() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RaftMessagePb::clear_leader() {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    leader_->clear();
  }
  clear_has_leader();
}
inline const ::std::string& RaftMessagePb::leader() const {
  return *leader_;
}
inline void RaftMessagePb::set_leader(const ::std::string& value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void RaftMessagePb::set_leader(const char* value) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(value);
}
inline void RaftMessagePb::set_leader(const char* value, size_t size) {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  leader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftMessagePb::mutable_leader() {
  set_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    leader_ = new ::std::string;
  }
  return leader_;
}
inline ::std::string* RaftMessagePb::release_leader() {
  clear_has_leader();
  if (leader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leader_;
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftMessagePb::set_allocated_leader(::std::string* leader) {
  if (leader_ != &::google::protobuf::internal::kEmptyString) {
    delete leader_;
  }
  if (leader) {
    set_has_leader();
    leader_ = leader;
  } else {
    clear_has_leader();
    leader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 data_committed = 4;
inline bool RaftMessagePb::has_data_committed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RaftMessagePb::set_has_data_committed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RaftMessagePb::clear_has_data_committed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RaftMessagePb::clear_data_committed() {
  data_committed_ = GOOGLE_LONGLONG(0);
  clear_has_data_committed();
}
inline ::google::protobuf::int64 RaftMessagePb::data_committed() const {
  return data_committed_;
}
inline void RaftMessagePb::set_data_committed(::google::protobuf::int64 value) {
  set_has_data_committed();
  data_committed_ = value;
}

// optional int64 config_committed = 5;
inline bool RaftMessagePb::has_config_committed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RaftMessagePb::set_has_config_committed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RaftMessagePb::clear_has_config_committed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RaftMessagePb::clear_config_committed() {
  config_committed_ = GOOGLE_LONGLONG(0);
  clear_has_config_committed();
}
inline ::google::protobuf::int64 RaftMessagePb::config_committed() const {
  return config_committed_;
}
inline void RaftMessagePb::set_config_committed(::google::protobuf::int64 value) {
  set_has_config_committed();
  config_committed_ = value;
}

// optional .raft.RaftLogEntryPb entry = 8;
inline bool RaftMessagePb::has_entry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RaftMessagePb::set_has_entry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RaftMessagePb::clear_has_entry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RaftMessagePb::clear_entry() {
  if (entry_ != NULL) entry_->::raft::RaftLogEntryPb::Clear();
  clear_has_entry();
}
inline const ::raft::RaftLogEntryPb& RaftMessagePb::entry() const {
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
}
inline ::raft::RaftLogEntryPb* RaftMessagePb::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::raft::RaftLogEntryPb;
  return entry_;
}
inline ::raft::RaftLogEntryPb* RaftMessagePb::release_entry() {
  clear_has_entry();
  ::raft::RaftLogEntryPb* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void RaftMessagePb::set_allocated_entry(::raft::RaftLogEntryPb* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
}

// optional bool nack = 9;
inline bool RaftMessagePb::has_nack() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RaftMessagePb::set_has_nack() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RaftMessagePb::clear_has_nack() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RaftMessagePb::clear_nack() {
  nack_ = false;
  clear_has_nack();
}
inline bool RaftMessagePb::nack() const {
  return nack_;
}
inline void RaftMessagePb::set_nack(bool value) {
  set_has_nack();
  nack_ = value;
}

// optional int64 last_log_term = 10;
inline bool RaftMessagePb::has_last_log_term() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RaftMessagePb::set_has_last_log_term() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RaftMessagePb::clear_has_last_log_term() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RaftMessagePb::clear_last_log_term() {
  last_log_term_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_term();
}
inline ::google::protobuf::int64 RaftMessagePb::last_log_term() const {
  return last_log_term_;
}
inline void RaftMessagePb::set_last_log_term(::google::protobuf::int64 value) {
  set_has_last_log_term();
  last_log_term_ = value;
}

// optional int64 last_log_index = 11;
inline bool RaftMessagePb::has_last_log_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RaftMessagePb::set_has_last_log_index() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RaftMessagePb::clear_has_last_log_index() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RaftMessagePb::clear_last_log_index() {
  last_log_index_ = GOOGLE_LONGLONG(0);
  clear_has_last_log_index();
}
inline ::google::protobuf::int64 RaftMessagePb::last_log_index() const {
  return last_log_index_;
}
inline void RaftMessagePb::set_last_log_index(::google::protobuf::int64 value) {
  set_has_last_log_index();
  last_log_index_ = value;
}

// optional string vote = 12;
inline bool RaftMessagePb::has_vote() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RaftMessagePb::set_has_vote() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RaftMessagePb::clear_has_vote() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RaftMessagePb::clear_vote() {
  if (vote_ != &::google::protobuf::internal::kEmptyString) {
    vote_->clear();
  }
  clear_has_vote();
}
inline const ::std::string& RaftMessagePb::vote() const {
  return *vote_;
}
inline void RaftMessagePb::set_vote(const ::std::string& value) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(value);
}
inline void RaftMessagePb::set_vote(const char* value) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(value);
}
inline void RaftMessagePb::set_vote(const char* value, size_t size) {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  vote_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RaftMessagePb::mutable_vote() {
  set_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    vote_ = new ::std::string;
  }
  return vote_;
}
inline ::std::string* RaftMessagePb::release_vote() {
  clear_has_vote();
  if (vote_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vote_;
    vote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RaftMessagePb::set_allocated_vote(::std::string* vote) {
  if (vote_ != &::google::protobuf::internal::kEmptyString) {
    delete vote_;
  }
  if (vote) {
    set_has_vote();
    vote_ = vote;
  } else {
    clear_has_vote();
    vote_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace raft

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_raft_2eproto__INCLUDED
